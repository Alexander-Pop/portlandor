<?php

use Drupal\redirect\Entity\Redirect;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Field\FieldStorageDefinitionInterface;

/**
 * Implements hook_entity_bundle_field_info_alter().
 */
function portland_legacy_redirects_entity_bundle_field_info_alter(&$fields, \Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle)
{
  _add_field_legacy_path_validation_constraint_path_exists($fields, $entity_type, $bundle);
}

/**
 * Add relative_path constraint to field_legacy_path if it exists in fields array for the given bundle.
 * Called by hook_entity_bundle_field_info_alter.
 */
function _add_field_legacy_path_validation_constraint_path_exists(&$fields, \Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle) {
  if (array_key_exists('field_legacy_path', $fields)) {
    $fields['field_legacy_path']->addConstraint('relative_path', []);
  }
}

/**
 * Implements hook_entity_base_field_info().
 */
function portland_legacy_redirects_entity_base_field_info($entity_type) {
  if ($entity_type->id() === 'node' || $entity_type->id() === 'group') {
    $fields = [];

    // add a field that allows the page's redirects (labeled as Legacy Paths) to be modified
    // outside the redirects UI.
    $fields['field_redirects'] = BaseFieldDefinition::create('string')
      ->setName('field_redirects')
      ->setLabel(t('Legacy Path'))
      ->setComputed(TRUE)
      ->setClass('\Drupal\portland_legacy_redirects\Field\RedirectList')
      ->setDisplayConfigurable('form', TRUE)
      ->setDisplayOptions('form', [
        'type' => 'text',
        'weight' => 50,
      ])
      ->setDescription(t('This field is used to create redirects to this page from legacy pages in the old site. Multiple paths may be entered in case several pages have been combined during migration. Once these paths are created, they may only be modified or removed by an administrator. Paths must be relative and start with a slash. For example, the page "https://www.portlandoregon.gov/bts/39479" should be entered as "/bts/39479."'))
      ->setCardinality(FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED);

      //      ->addConstraint('FeedTitle');


    return $fields;
  }
}

/**
 * Implements hook_form_alter().
 */
function portland_legacy_redirects_form_alter(&$form, FormStateInterface $form_state, $form_id)
{
  //_sync_node_and_group_redirects($form, $form_state);
}

/**
 * Queries db for redirects that point to this node's URI and adds them to the legacy_path field.
 * Called by hook_form_alter hook.
 */
function _sync_node_and_group_redirects(&$form, $form_state) {
  // filter out requests by checking the entity type. not all form objects support the getEntityTypeId method,
  // so we need to do some checks first so nothing breaks.
  $form_object = $form_state->getFormObject();
  if ($form_object && method_exists($form_object, 'getEntity')) {
    $entity = $form_object->getEntity();
    if ($entity && method_exists($entity, 'getEntityTypeId')) {
      $type = $entity->getEntityTypeId();
      // we want to check for and sync redirects on any node of a content type that includes the legacy path field
      if (($type == 'node' || $type == 'group') && array_key_exists('field_legacy_path', $form)) {
        // only  call the sync function if the node has already been saved
        $this_node = \Drupal::routeMatch()->getParameter($type);
        if ($this_node) {
          $nid = $this_node->Id();

          // if this is a new node form, exit this function
          $this_node = \Drupal::routeMatch()->getParameter($type);
          if (!$this_node) return;

          $nid = $this_node->Id();
          //$redirect_url = "entity:$type/$nid";
          // redirects that are added manually through the UI have a different uri pattern, so we need
          // to do two queries to make sure we're getting them all.
          $redirects = \Drupal::service('redirect.repository')->findByDestinationUri(["internal:/$type/$nid", "entity:$type/$nid"]);

          $new_deltas = array();
          $field = $form['field_legacy_path']['widget'];
          $max_delta = $field['#max_delta'];

          // if max_delta is zero, that means no paths have been saved, and a blank field has
          // been added to the form. we want that blank field to be at the end.
          $delta_counter = $max_delta == 0 ? $max_delta : $max_delta + 1;
          $save_empty_delta;
          if ($max_delta == 0) {
            $delta_counter = 0;
            $save_empty_delta = $form['field_legacy_path']['widget'][0];
            unset($form['field_legacy_path']['widget'][0]);
          } else {
            $delta_counter = $max_delta + 1;
          }

          // need to make sure there's a field delta for each of the redirects in $redirects,
          foreach ($redirects as $key => $redirect) {
            $source_path = $redirect->getSource()['path'];
            // spin through field_legacy_path values to see if $source_path is in there. if not, add.
            for ($i = 0; $i < $max_delta; $i++) {
              $source_value = _portland_legacy_redirects_utility_strip_leading_slash($field[$i]['value']['#default_value']);
              if ($source_path == $source_value) {
                continue 2;
              }
            }

            // if there wasn't a match and break by this point, add $source_path to a temporary array,
            // which will be appended to field_legacy_path widget after the loops.
            $new_deltas[$delta_counter] = [
              '#delta' => $delta_counter,
              '#weight' => $delta_counter,
              'value' => [
                '#type' => 'textfield',
                '#size' => 60,
                '#maxlength' => 255,
                '#default_value' => '/' . $source_path
              ],
            ];

            $delta_counter++;
          }

          // now add new deltas to field
          foreach ($new_deltas as $idx => $delta) {
            $form['field_legacy_path']['widget'][] = $delta;
          }
          if ($max_delta == 0) {
            $form['field_legacy_path']['widget'][] = $save_empty_delta;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_update.
 */
function portland_legacy_redirects_entity_update($entity) {
  //_portland_legacy_redirects_create_redirects($entity);
}

/**
 * Creates redirects for entity in the redirects table.
 * Called by hook_entity_update.
 */
function _portland_legacy_redirects_create_redirects($entity) {
  // if this is a node that has the legacy path field, create redirects
  $type = $entity->getEntityTypeId();
  if (($type == 'node' || $type == 'group') && $entity->hasField('field_legacy_path')){

    // $entity->toUrl()->toUriString() generates a URI string that looks like this: route:entity.node.canonical;node=332.
    // The Redirect module stores a string that looks like this: entity:node/332.
    // Both work for redirection, but only ones in the latter format appear in the node's URL Redirects panel.
    $nid = $entity->id();
    $this_redirect_url = "entity:$type/" . $nid;

    // NOTE: on form_alter as the form is loading, paths that are in the redirects table
    // but not yet stored in the field are added in. this means the field and field_orig
    // values will always appear to be the same when this function is called.

    // an array of paths from the entity edit form
    $field_legacy_path = $entity->get('field_legacy_path')->getValue();

    // existing redirects that match this uri
    $redirects = \Drupal::service('redirect.repository')->findByDestinationUri(["internal:/$type/$nid", "entity:$type/$nid"]);

    // 1. spin through field values and add any to redirects table that aren't already there.
    foreach ($field_legacy_path as $delta => $value) {
      $str_value = $value['value'];
      // remove leading slash from value
      if (substr($str_value, 0, 1) == "/") {
        $str_value = substr($str_value, 1, strlen($str_value));
      }
      $found = _portland_legacy_redirects_utility_find_redirect_from_table($redirects, $str_value);
      if (!$found) {
        // create redirect
        Redirect::create([
          'redirect_source' => $str_value,
          'redirect_redirect' => $this_redirect_url,
          'language' => 'en',
          'status_code' => 301,
        ])->save();
      }
    }

    // 2. spin through redirects and remove any field values that arent there
    foreach ($redirects as $delta => $redirect) {
      $redirect_path = $redirect->get('redirect_source')[0]->getValue()['path'];
      $found = _portland_legacy_redirects_utility_find_redirect_from_field($field_legacy_path, $redirect_path);
      if (!$found) {
        // remove from table
        $redirect->delete();
      }
    }
  }
}

function _portland_legacy_redirects_utility_find_redirect_from_table($redirects, $find) {
  foreach ($redirects as $delta => $redirect) {
    $redirect_path = $redirect->get('redirect_source')[0]->getValue()['path'];
    if ($redirect_path == $find) {
      return $redirect;
    }
  }
}

function _portland_legacy_redirects_utility_find_redirect_from_field($field, $find) {
  foreach ($field as $delta => $path) {
    $redirect_path = $path['value'];
    if ($redirect_path == '/' . $find) {
      return $redirect_path;
    }
  }
}

/**
 * Strips leading slash from a path.
 */
function _portland_legacy_redirects_utility_strip_leading_slash($path) {
  return substr($path, 0, 1) == "/" ? substr($path, 1) : $path;
}

    // if (!in_array($field_legacy_path, $redirects)) { // this won't work
    //   Redirect::create([
    //     'redirect_source' => $value['value'],
    //     'redirect_redirect' => $this_redirect_url,
    //     'status_code' => 301,
    //   ])->save();
    // }

    // spin through existing redirects and remove any that aren't in $field_redirects
    // and create any from $field_redirects that aren't there.



    // foreach ($field as $delta => $value) {
    //   $from_orig = $field_orig[$delta]['value'];
    //   $from = $value['value']; // from should always be unique because you can't have a source URL pointing to multiple destinations.
    //   if (substr($from, 0, 1) == "/") { $from = substr($from, 1); }

    //   $existing_from = \Drupal::service('redirect.repository')->findBySourcePath($from);
    //   if ($existing_from) { continue; }

    //   Redirect::create([
    //     'redirect_source' => $from,
    //     'redirect_redirect' => $this_redirect_url,
    //     'status_code' => 301,
    //   ])->save();
    // }
